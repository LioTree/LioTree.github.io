<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>CVE-2020-1938 幽灵猫 - LionTree</title>
  <link rel="icon" href="https://i.imgur.com/SrZt9VU.jpg" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content=漏洞分析,java>
  
  
  
    <link rel="alternate" href="/atom.xml " title="LionTree" type="application/atom+xml">
  

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">LionTree</a>
    <div class="subtitle"></div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/summary" class="menu-item-link">Summary</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
        <li class="menu-item">
          <a href="/atom.xml" class="menu-item-link">RSS</a>
        </li>
      
    </ul>
  </nav>
</header>

<article class="post">
  <div class="post-title">
    <h1 class="article-title">CVE-2020-1938 幽灵猫</h1>
  </div>

  <!-- 文章目录 -->
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#环境搭建"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#复现"><span class="toc-text">复现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tomcat架构"><span class="toc-text">Tomcat架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#漏洞分析"><span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么Tomcat会根据报文的内容设置属性？"><span class="toc-text">为什么Tomcat会根据报文的内容设置属性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么设置这些属性可以达到文件读取和包含的效果？"><span class="toc-text">为什么设置这些属性可以达到文件读取和包含的效果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么只能读取或包含web应用目录的文件？"><span class="toc-text">为什么只能读取或包含web应用目录的文件？</span></a></li></ol></li></ol>

  <div class="post-content">
    <p>三个月没写过博客了，上学期的学期压缩属实难顶</p>
<p>最近在某生产环境碰到了这个洞，因为通过这个洞能了解到到很多Tomcat的东西，所以炒炒冷饭水一篇当笔记用，主要参考了<a href="https://www.guildhab.top/?p=2406" target="_blank" rel="noopener">CVE-2020-1938 幽灵猫( GhostCat ) Tomcat-Ajp 协议任意文件读取/JSP文件包含漏洞分析</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>java的环境还是日常难搞…</p>
<p>主要流程可以参见<a href="https://blog.csdn.net/u013268035/article/details/81349341" target="_blank" rel="noopener">IDEA导入Tomcat源码</a></p>
<p>碰到的一个坑是我最开始使用了新的阿里云maven镜像<code>https://maven.aliyun.com/repository/public</code>，<code>pom.xml</code>中有很多包都找不到，换成旧的<code>http://maven.aliyun.com/nexus/content/groups/public/</code>就行了</p>
<p>另外maven有两个<code>settings.xml</code>，需要注意下优先级，见<a href="https://blog.csdn.net/weixin_42128568/article/details/107321272" target="_blank" rel="noopener">关于maven的两个setting.xml读取顺序解析</a></p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>使用<a href="https://github.com/hypn0s/AJPy" target="_blank" rel="noopener">AJPy</a>复现：</p>
<p><img src="/images/AJPy.JPG" alt=""></p>
<p>wireshark抓包：</p>
<p><img src="//AJPy_wireshark.JPG" alt=""></p>
<p>需要注意的是AJPy其实默认走的是文件包含的payload，只是看起来效果是一样的。文件读取需要将<code>tomcat.py</code>中的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdrs, data = bf.perform_request(<span class="string">"/"</span> + args.webapp + <span class="string">"/xxxxx.jsp"</span>, attributes=attributes)</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdrs, data = bf.perform_request(<span class="string">"/"</span> + args.webapp + <span class="string">"/xxxxx"</span>, attributes=attributes)</span><br></pre></td></tr></table></figure>

<p>抓包后变为：</p>
<p><img src="/images/AJPy_wireshark2.JPG" alt=""></p>
<p>可以看到AJP协议和HTTP协议非常类似，甚至连头写的都是<code>HTTP/1.1</code></p>
<p>从发送的报文中可以猜测是通过设置<code>Servlet</code>中的一些属性来达到文件读取和包含的效果的，接下来的核心问题就是：</p>
<ul>
<li><p>为什么Tomcat会根据报文的内容设置属性？</p>
</li>
<li><p>为什么设置这些属性可以达到文件读取和包含的效果？</p>
</li>
<li><p>为什么只能读取或包含web应用目录的文件</p>
</li>
</ul>
<h1 id="Tomcat架构"><a href="#Tomcat架构" class="headerlink" title="Tomcat架构"></a>Tomcat架构</h1><p><a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">四张图带你了解Tomcat系统架构–让面试官颤抖的Tomcat回答系列！</a>这篇文章写的挺清楚了，自己简单总结一下</p>
<ul>
<li><p>Tomcat中最顶层的容器是<code>Server</code>，代表整个服务器，<code>Server</code>中可以包含多个<code>Service</code></p>
</li>
<li><p><code>Service</code>由<code>Connectors</code>和<code>Container</code>组成</p>
</li>
<li><p><code>Connectors</code>负责接受请求，封装好<code>Request</code>和<code>Response</code>交给<code>Container</code>处理</p>
<ul>
<li><p>一个<code>Service</code>可以配置多个<code>Connectors</code>，比如同时有<code>http</code>和<code>https</code></p>
</li>
<li><p><code>Connectors</code>由三个部分组成：</p>
<ul>
<li><p><code>Endpoint</code>：负责处理<code>socket</code>连接</p>
</li>
<li><p><code>Processor</code>：负责将<code>tcp</code>流解析为<code>http</code>，封装出<code>Request</code>和<code>Response</code>对象</p>
</li>
<li><p><code>Adapter</code>：将封装好的<code>Request</code>和<code>Response</code>交给<code>Container</code>处理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Container</code>封装和管理<code>Servlet</code>，具体处理<code>Request</code>和<code>Response</code></p>
<ul>
<li><p>一个<code>Service</code>只能有一个<code>Container</code></p>
</li>
<li><p><code>Container</code>中包含了四个层层包含的子容器：</p>
<ul>
<li><p><code>Engine</code>：只能有一个，将请求发给不同的<code>Host</code></p>
</li>
<li><p><code>Host</code>：代表一个虚拟主机，可以配置多个</p>
</li>
<li><p><code>Context</code>：代表一个应用，也就是<code>webapps</code>下的一个文件夹，一个<code>Host</code>可以配置多个<code>Context</code></p>
</li>
<li><p><code>Wrapper</code>：代表一个<code>Servlet</code>的封装</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>详细的源码分析网上已经很多了，这里就简单记录下上面的三个问题</p>
<h2 id="为什么Tomcat会根据报文的内容设置属性？"><a href="#为什么Tomcat会根据报文的内容设置属性？" class="headerlink" title="为什么Tomcat会根据报文的内容设置属性？"></a>为什么Tomcat会根据报文的内容设置属性？</h2><p>AJP协议的<code>Processor</code>会调用<code>org.apache.coyote.ajp.AbstractAjpProcessor.prepareRequest()</code>方法来封装<code>request</code>对象，其中有这样的代码：</p>
<p><img src="/images/prepareRequest1.JPG" alt=""></p>
<p><img src="/images/prepareRequest2.JPG" alt=""></p>
<p><img src="/images/prepareRequest3.JPG" alt=""></p>
<p>可以看到AJP报文中的内容被设置到了<code>request</code>对象中去</p>
<p>为什么Tomcat会有这样一个功能？</p>
<p>AJP协议主要用于反向代理服务器和Tomcat之间的通信，因此可以想到这个功能的目的是让反向代理服务器能够设置Tomcat的一些属性</p>
<p>在修洞后的<code>webapps/docs/config/ajp.xml</code>中也验证了这个想法：</p>
<p><img src="/images/allowedRequestAttributesPattern.JPG" alt=""></p>
<p>实际上Tomcat修洞的方法也就是在<code>prepareRequest()</code>中对传入的属性设置了一个白名单</p>
<h2 id="为什么设置这些属性可以达到文件读取和包含的效果？"><a href="#为什么设置这些属性可以达到文件读取和包含的效果？" class="headerlink" title="为什么设置这些属性可以达到文件读取和包含的效果？"></a>为什么设置这些属性可以达到文件读取和包含的效果？</h2><p><code>prepareRequest()</code>中只是将这些属性保存在了<code>request</code>对象中，要解决这个问题还要继续跟下去</p>
<p>以文件读取为例，最终会执行到<code>org.apache.catalina.servlets.DefaultServlet.doGet()</code>方法中。这也很好理解，文件读取payload中访问了<code>/xxxxx</code>这样一个不存在的路径，所以会交给<code>DefaultServlet</code>进行处理。文件包含的话访问的是jsp文件，则会交给<code>JspServlet</code>处理</p>
<p><code>doGet()</code>方法又会调用<code>org.apache.catalina.servlets.DefaultServlet.serveResource()</code>方法尝试去返回一个静态资源</p>
<p><img src="/images/serveResource.JPG" alt=""></p>
<p><img src="/images/getRelativePath.JPG" alt=""></p>
<p><img src="/images/getRelativePath2.JPG" alt=""></p>
<p>显然问题出在<code>getRelativePath()</code>上，这个方法从<code>request</code>中取出了我们设置的属性并拼接到了<code>result</code>中去，之后tomcat会根据返回的<code>path</code>读取对应的文件</p>
<p>为什么<code>getRelativePath()</code>会这样做？</p>
<p>参考<a href="https://openhome.cc/Gossip/ServletJSP/DispatchRequest.html" target="_blank" rel="noopener">調派請求</a>，在<code>request</code>中设置<code>javax.servlet.include.path_info</code>等属性本来就是jsp文件包含时的常规操作</p>
<p><code>getRelativePath()</code>则对文件包含的情况进行了考虑，假如<code>request</code>中存在这些属性就根据这些属性构造<code>result</code></p>
<h2 id="为什么只能读取或包含web应用目录的文件？"><a href="#为什么只能读取或包含web应用目录的文件？" class="headerlink" title="为什么只能读取或包含web应用目录的文件？"></a>为什么只能读取或包含web应用目录的文件？</h2><p>继续跟下去可以发现在读文件的时候会对路径进行检查，以读取<code>../../test.txt</code>为例</p>
<p><img src="/images/file.JPG" alt=""></p>
<p><img src="/images/validate.JPG" alt=""></p>

  </div>
  <div class="post-meta">
    <span class="post-time" style="color:#646060;font-size:13px">2021-01-06</span>
  </div>

  <div class="post-footer">
    
      <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="tag">漏洞分析</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>

<!-- 评论插件 -->

<footer>
  2025
  <span class="author">
    LionTree
  </span>
</footer>


    </div>
  </body>
</html>